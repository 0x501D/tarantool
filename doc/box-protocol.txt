; Tarantool IPROTO protocol.
;
; The latest version of this document can be found in
; tarantool source tree, doc/box-protocol.txt
;
; IPROTO is a binary request/response protocol that features a
; complete access to Tarantool functionality, including:
; - request multiplexing, e.g. ability to asynchronously issue
;   multiple requests via the same connection
; - response format that supports zero-copy writes
;
; For data structuring and encoding, the protocol uses msgpack
; data format, see http://msgpack.org
;
; Since msgpack uses a variying representation for compound
; data structures, such as arrays and maps, the exact byte
; sequence mandated by msgpack format is omitted in this spec.
; Instead, to specify that some contents is part of a msgpack
; map {} (curly braces) will be used, of a msgpack array - []
; (square brackets), to define a single key/value pair
; in a map - a semicolon.
; If a piece of data is sent as a msgpack int, "" will be used,
; integers will be denoted without quotes.
; For example, a reply to ping command in this notation looks
; like:
; { len: 0, code: 0, sync: uint }
; The binary layout of reply, according to msgpack speck is:
; 0x83, 0, 0, 1, 0, 3, 0xce, int8, uint8, uint8, uint8

; The structure of requests and responses is described below.
;
; All requests and responses utilize the same basic structure

<packet> ::= <request> | <response>

<request> ::= <len><header><body>
<response> ::= <len><header><body>

; <len> is the length of the packet, in message pack format.
; Implementor note: for simplicity of the implementation,
; the server never "compresses" the packet length, i.e.
; it is always passed as MessagePack 32-bit unsigned int,
; 0xce b4 b3 b2 b1 (5 bytes)
;
<len> ::= message pack unsigned int

;
; Both <header> and <body> are message pack maps:

<header> ::= { (<key> : <value>)+ }
<body> ::= { (<key> : <value>)+ }

; They only differ in the allowed set of keys and values,
; and the key defines the type of value that follows.
; If a key is missing, and expects an integer value,
; the missing value is always assumed to be 0. If the
; missing key assumes a string value, the string is assumed
; to be empty.

<key> ::= <header_key> | <body_key>

<header_key> ::= <code> | <sync>

;
; <code> is request code or response code
;

<code> ::= 0 ; value is <uint32>

; Value of <code> key in request can be:
; 0  -- <ping>
; 1  -- <select>
; 2  -- <insert>
; 3  -- <replace>
; 4  -- <update>
; 5  -- <delete>
; 6  -- <call>

; Value of <code> in response is:
; 0  -- OK
; anything else (32-bit int) - Tarantool error code
; If response <code> is 0 (success), response body contains zero or
; more tuples, otherwise it carries an error message that corresponds
; to the return code.

; <sync> is a unique request identifier, preserved in the response,
; The identifier is necessary to allow request multiplexing --
; i.e. sending multiple requests through the same connection
; before fetching a response to any of them.
; The value of the identifier currently bears no meaning to the
; server. Consequently, <sync> can be 0 or two requests
; can have an identical id.

<sync> ::= 1 ; value is <uint32>

<body_key> ::= <request_key> | <response_key>

; Different request types allow different keys in the body:

<request_key> ::= <select> | <replace> | <delete> | <update> | <call>

; Specify which space to query, which index in the space
; to use, offset in the resulting tuple set (set to 0 for no offset),
; a limit (set to 4294967295 for no limit), and a key to use in lookup.

; Find tuples matching the search pattern
<select> ::= <space> | <index> | <iterator> | <offset> | <limit> | <tuple>

; Insert a tuple into the space or replace an existing one.

<replace> ::= <space> | <index> | <tuple>

; Insert is similar to replace, but will return a duplicate key
; error if such tuple already exists.
<insert> ::= <space> | <index> | <tuple>

; Delete a tuple
<delete_key> ::= <space> | <index> | <tuple>

; Update a tuple
<udpate> ::= <space> | <index> | <tuple> | <ops>

; Call a stored function
<call> ::= <name> | <tuple>

; As can be seen from the grammar some requests have common keys,
; whereas other keys can be present only in a body of a single
; request type.


; <space> Space to use in the request
; The find the numeric space id by space name, one
; must first query "_space" system space.
<space> ::= 2 ; value is <uint32>

; <index> Index to use in the request
; Similarly to space, to find the  numeric index id
; by index name, one must query the "_index" system space.

<index> ::= 3 ; value is <uint32>

; <tuple> defines the actual argument of the operation
; When present in <select> or <update> it defines a (maybe compound)
; search key, whereas in <replace> it defines the tuple which
; will be inserted into the database.
; In <call> it defines call arguments.
; When request body allows <tuple> as a key, it must always
; be present, since otherwise the request is meaningless.

<tuple> ::= 4 ; value is an arbitrary msgpack array

; Only in select, offset in the result set, expects <uint32> value

; Offset in the result set, <select> only

<offset> ::= 5 ; value is <uint32>

; Limit in the result set, <select> only

<limit> ::= 6 ; value is <uint32>

; Iterator type to use in search, <select> only

<iterator> ::= 7 ; the only supported value for now is 0

; Name of the function to call,
<name> ::= 8 ; value is "string"

; Result set, array of tuples, present only if there is no error
; (code = ER_OK)

<ops> ::= 9 ; expects <op_list> as value

<op_list> ::= [ (<operation>)+ ]

;
; Operations are optional and exist solely to allow
; updates of individual fields.
;

<operation> ::= <field_no><op_code><op_arg>

;
; Field index, specifies argument(s) of the operation
;

<field_no> ::= <int32>

;
; The operation(s) below operate on fields of arbitrary types:
; 0 - assign operation argument to field <field_no>;
;     will extend the tuple if <field_no> == <max_field_no> + 1
;
; The following operation(s) are only defined for integer
; types (32 and 64 bit):
; 1 - add argument to field <field_no>, both arguments
; are treated as signed 32 or 64 -bit ints
; 2 - bitwise AND of argument and field <field_no>
; 3 - bitwise XOR of argument and field <field_no>
; 4 - bitwise OR of argument and field <field_no>
; For arithmetic operations, size of the argument must be
; less or equal to the size of the field: it's possible
; to add 32-bit ints to 32- and 64- bit fields, but
; 64-bit ints can be added only to 64-bit fields.
; Tarantool 1.3.5 features one more command, which operates
; on strings:
; 5 - implementation of Perl 'splice' command
;
; The operation(s) below operate on fields of arbitrary types:
; 6 - delete <field_no>
; 7 - insert before <field_no>

<op_code> ::= <int8> # 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7

;
; It's an error to specify an argument of a type that
; differs from expected type.
;
<op_arg> ::= <field> | <op_arg_splice>

; For simple operations <op_arg> field contains either a string
; to assign, a number to add or subtract.
; When <op_code> is splice, <field> has to carry not one argument,
; but 3: offset in the target field, number of bytes to remove,
; string argument to inject. Since <op_arg> is always a <field>,
; field data in case of splice argument contains 3 nested <field>
; objects, which store the arguments:

<op_arg_splice> ::= <message_pack_array(3)> # <offset><length><string>


; The server always returns a tuple or tuples, when found, on success,
; I.e. on success, response <body> contains <set> key.
; For select/update/delete, it's the tuple that matched
; the search criterion. For <replace>, it's the inserted tuple.
; For <call>, it's whatever the called function returns.

<response_key> = <data> | <error>

; Set of tuples in the response
<data> ::= 10 ; value is a message pack array of tuples

; Error message, present in the response only if there is an error
<error> ::= 11 ; value is a message pack string

; The error <code> consists of the actual error code
; and request completion status, which is complementary:
; it can be deduced from the error code. There are only
; 3 completion status codes in use:
; 0  - success; The only possible error code with this status is
       0, ER_OK
; 1  - try again; An indicator of an intermittent error.
;      Usually is returned when two clients attempt to change
;      the same tuple simultaneously.
;      (<update> is not always done atomically)
; 2  - error
;
; The error code holds the actual error. Existing error codes include:
;
;  Completion status 0 (success)
;  -----------------------------
;  0x00000000 -- ER_OK
;
;  Completion status 1 (try again)
;  -------------------------------
;  0x00000401 -- ER_TUPLE_IS_RO
;                The requested data is blocked from modification
;
;  0x00000601 -- ER_TUPLE_IS_LOCKED
;                The requested data is not available
;
;  0x00000701 -- ER_MEMORY_ISSUE
;                An error occurred when allocating memory
;
;  Completion status 2 (error)
;  ---------------------------
;
;  0x00000102 -- ER_NONMASTER
;                An attempt was made to change data on a read-only port
;
;  0x00000202 -- ER_ILLEGAL_PARAMS
;                Malformed query
;
;  0x00000a02 -- ER_UNSUPPORTED_COMMAND
;                The query is not recognized
;
;  0x00001e02 -- ER_WRONG_FIELD
;                An unknown field was requested
;
;  0x00001f02 -- ER_WRONG_NUMBER
;                An out-of-range numeric value was included in the query
;
;  0x00002002 -- ER_DUPLICATE
;                An attempt was made to create an object with an existing key.
;
;  0x00002602 -- ER_WRONG_VERSION
;                The protocol version is not supported
;
;  0x00002702 -- ER_WAL_IO
;                WAL I/O error
;
; Convenience macros which define hexadecimal constants for
; <int32> return codes (completion status + code) can be found
; in include/errcode.h.

; vim: syntax=bnf
