-- ----------------------------------------------------------------
-- LIMITS
-- ----------------------------------------------------------------
box.schema.SYSTEM_ID_MIN
---
- 256
...
box.schema.FIELD_MAX
---
- 2147483647
...
box.schema.INDEX_FIELD_MAX
---
- 32767
...
box.schema.NAME_MAX
---
- 32
...
box.schema.INDEX_ID
---
- 288
...
box.schema.SPACE_ID
---
- 280
...
box.schema.INDEX_MAX
---
- 10
...
box.schema.SPACE_MAX
---
- 2147483647
...
box.schema.SYSTEM_ID_MAX
---
- 511
...
box.schema.SCHEMA_ID
---
- 272
...
box.schema.FORMAT_ID_MAX
---
- 65534
...
-- ----------------------------------------------------------------
-- CREATE SPACE
-- ----------------------------------------------------------------
s = box.schema.create_space('tweedledum')
---
...
-- space already exists
box.schema.create_space('tweedledum')
---
- error: Space 'tweedledum' already exists
...
-- create if not exists
s = box.schema.create_space('tweedledum', { if_not_exists = true })
---
...
s:drop()
---
...
-- no such space
s:drop()
---
- error: Space 512 does not exist
...
-- explicit space id
s = box.schema.create_space('tweedledum', { id = 3000 })
---
...
s.n
---
- 3000
...
-- duplicate id
box.schema.create_space('tweedledee', { id = 3000 })
---
- error: Duplicate key exists in unique index 0
...
-- stupid space id
box.schema.create_space('tweedledee', { id = 'tweedledee' })
---
- error: 'Tuple field 0 type does not match one required by operation: expected NUM'
...
s:drop()
---
...
-- too long space name
box.schema.create_space(string.rep('tweedledee', 100))
---
- error: 'Failed to create space 512: space name is too long'
...
-- space name limit
box.schema.create_space(string.rep('t', box.schema.NAME_MAX)..'_')
---
- error: 'Failed to create space 512: space name is too long'
...
s = box.schema.create_space(string.rep('t', box.schema.NAME_MAX - 1)..'_')
---
...
s.name
---
- ttttttttttttttttttttttttttttttt_
...
s:drop()
---
...
s = box.schema.create_space(string.rep('t', box.schema.NAME_MAX - 2)..'_')
---
...
s.name
---
- tttttttttttttttttttttttttttttt_
...
s:drop()
---
...
-- space with no indexes - test update, delete, select, truncate
s = box.schema.create_space('tweedledum')
---
...
s:insert(0)
---
- error: 'No index #0 is defined in space 512'
...
s:select(0)
---
- error: 'No index #0 is defined in space 512'
...
s:select_range(0, 0, 0)
---
- error: '[string "-- schema.lua (internal file)..."]:174: attempt to index a nil
    value'
...
s:delete(0)
---
- error: 'No index #0 is defined in space 512'
...
s:update(0, "=p", 0, 0)
---
- error: 'No index #0 is defined in space 512'
...
s:replace(0)
---
- error: 'No index #0 is defined in space 512'
...
s.index[0]
---
- null
...
s:truncate()
---
- error: 'No index #0 is defined in space 512'
...
s.enabled
---
- false
...
-- enabled/disabled transition
s:create_index('primary', 'hash', { parts = { 0, 'num' } })
---
...
s.enabled
---
- true
...
-- rename space - same name
s:rename('tweedledum')
---
...
s.name
---
- tweedledum
...
-- rename space - different name
s:rename('tweedledee')
---
...
s.name
---
- tweedledee
...
-- the reference from box.space[] to the space by old name should be gone
box.space['tweedledum']
---
- null
...
-- rename space - bad name
s:rename(string.rep('t', box.schema.NAME_MAX * 2))
---
- error: 'Can''t modify space 512: space name is too long'
...
s.name
---
- tweedledee
...
-- access to a renamed space
s:insert(0)
---
- [0]
...
s:delete(0)
---
- [0]
...
-- cleanup
s:drop()
---
...
-- create a space with reserved id (ok, but warns in the log)
s = box.schema.create_space('test', { id = 256 })
---
...
s.n
---
- 256
...
s:drop()
---
...
s = box.schema.create_space('test', { arity = 2 })
---
...
s.arity
---
- 2
...
s:create_index('primary', 'tree', { parts = { 0, 'num' } })
---
...
-- arity actually works
s:insert(1)
---
- error: Tuple field count 1 does not match space 512 arity 2
...
s:insert(1, 2)
---
- [1, 2]
...
s:insert(1, 2, 3)
---
- error: Tuple field count 3 does not match space 512 arity 2
...
s:select(0)
---
- [1, 2]
...
-- increase arity -- error
box.space['_space']:update(s.n, "=p", 1, 3)
---
- error: 'Can''t modify space 512: can not change arity on a non-empty space'
...
s:select(0)
---
- [1, 2]
...
-- decrease arity - error
box.space['_space']:update(s.n, "=p", 1, 1)
---
- error: 'Can''t modify space 512: can not change arity on a non-empty space'
...
-- remove arity - ok
box.space['_space']:update(s.n, "=p", 1, 0)
---
- [512, 0, 1953719668]
...
s:select(0)
---
- [1, 2]
...
-- increase arity - error
box.space['_space']:update(s.n, "=p", 1, 3)
---
- error: 'Can''t modify space 512: can not change arity on a non-empty space'
...
s:truncate()
---
...
s:select(0)
---
...
-- set arity of an empty space
box.space['_space']:update(s.n, "=p", 1, 3)
---
- [512, 3, 1953719668]
...
s:select(0)
---
...
-- arity actually works
s:insert(3, 4)
---
- error: Tuple field count 2 does not match space 512 arity 3
...
s:insert(3, 4, 5)
---
- [3, 4, 5]
...
s:insert(3, 4, 5, 6)
---
- error: Tuple field count 4 does not match space 512 arity 3
...
s:insert(7, 8, 9)
---
- [7, 8, 9]
...
s:select(0)
---
- [3, 4, 5]
- [7, 8, 9]
...
-- check transition of space from enabled to disabled on
-- deletion of the primary key
s.enabled
---
- true
...
s.index[0]:drop()
---
...
s.enabled
---
- false
...
s.index[0]
---
- null
...
-- "disabled" on
-- deletion of primary key
s:drop()
---
...
-- ----------------------------------------------------------------
-- CREATE INDEX
-- ----------------------------------------------------------------
--
s = box.schema.create_space('test')
---
...
--# setopt delimiter ';'
for k=0, box.schema.INDEX_MAX + 1, 1 do
    s:create_index('i'..k, 'hash', { parts = {0, 'num'} } )
end;
---
- error: 'Can''t create or modify index 10 in space 512: index id too big'
...
--# setopt delimiter ''
-- cleanup
for k, v in pairs (s.index) do if v.id ~= 0 then v:drop() end end
---
...
-- test limits enforced in key_def_check:
-- unknown index type
s:create_index('test', 'nosuchtype', { parts = {0, 'num'} })
---
- error: Unsupported index type supplied for index 1 in space 512
...
-- hash index is not unique
s:create_index('test', 'hash', {parts = {0, 'num'}, unique = false })
---
- error: 'Can''t create or modify index 1 in space 512: HASH index must be unique'
...
-- bitset index is unique
s:create_index('test', 'bitset', {parts = {0, 'num'}, unique = true })
---
- error: 'Can''t create or modify index 1 in space 512: BITSET can not be unique'
...
-- bitset index is multipart
s:create_index('test', 'bitset', {parts = {0, 'num', 1, 'num'}})
---
- error: 'Can''t create or modify index 1 in space 512: BITSET index key can not be
    multipart'
...
-- part count must be positive
s:create_index('test', 'hash', {parts = {}})
---
- error: 'Can''t create or modify index 1 in space 512: part count must be positive'
...
-- part count must be positive
s:create_index('test', 'hash', {parts = { 0 }})
---
- error: 'Can''t create or modify index 1 in space 512: part count must be positive'
...
-- unknown field type
s:create_index('test', 'hash', {parts = { 0, 'nosuchtype' }})
---
- error: 'Can''t create or modify index 1 in space 512: unknown field type'
...
-- bad field no
s:create_index('test', 'hash', {parts = { 'qq', 'nosuchtype' }})
---
- error: 'Tuple field 6 type does not match one required by operation: expected NUM'
...
-- big field no
s:create_index('test', 'hash', {parts = { box.schema.FIELD_MAX, 'num' }})
---
- error: 'Can''t create or modify index 1 in space 512: field no is too big'
...
s:create_index('test', 'hash', {parts = { box.schema.FIELD_MAX - 1, 'num' }})
---
- error: 'Can''t create or modify index 1 in space 512: field no is too big'
...
s:create_index('test', 'hash', {parts = { box.schema.FIELD_MAX + 90, 'num' }})
---
- error: 'Can''t create or modify index 1 in space 512: field no is too big'
...
s:create_index('test', 'hash', {parts = { box.schema.INDEX_FIELD_MAX + 1, 'num' }})
---
- error: 'Can''t create or modify index 1 in space 512: field no is too big'
...
s:create_index('t1', 'hash', {parts = { box.schema.INDEX_FIELD_MAX, 'num' }})
---
...
s:create_index('t2', 'hash', {parts = { box.schema.INDEX_FIELD_MAX - 1, 'num' }})
---
...
-- cleanup
s:drop()
---
...
s = box.schema.create_space('test')
---
...
-- same part can't be indexed twice
s:create_index('t1', 'hash', {parts = { 0, 'num', 0, 'str' }})
---
- error: 'Can''t create or modify index 0 in space 512: same key part is indexed twice'
...
-- a lot of key parts
parts = {}
---
...
--# setopt delimiter ';'
for k=0, box.schema.INDEX_PART_MAX, 1 do
    table.insert(parts, k)
    table.insert(parts, 'num')
end;
---
...
#parts;
---
- 512
...
s:create_index('t1', 'hash', {parts = parts});
---
- error: 'Can''t create or modify index 0 in space 512: too many key parts'
...
parts = {};
---
...
for k=1, box.schema.INDEX_PART_MAX, 1 do
    table.insert(parts, k)
    table.insert(parts, 'num')
end;
---
...
#parts;
---
- 510
...
s:create_index('t1', 'hash', {parts = parts});
---
...
--# setopt delimiter ''
-- this is actually incorrect since key_field is a lua table
-- and length of a lua table which has index 0 set is not correct
#s.index[0].key_field
---
- 254
...
-- cleanup
s:drop()
---
...
-- check costraints in tuple_format_new()
s = box.schema.create_space('test')
---
...
s:create_index('t1', 'hash', { parts = { 0, 'num' }})
---
...
-- field type contradicts field type of another index
s:create_index('t2', 'hash', { parts = { 0, 'str' }})
---
- error: Ambiguous field type in index 1, key part 0. Requested type is STR but the
    field has previously been defined as NUM
...
-- ok
s:create_index('t2', 'hash', { parts = { 1, 'str' }})
---
...
-- don't allow drop of the primary key in presence of other keys
s.index[0]:drop()
---
- error: Can't drop primary key in space 512 while secondary keys exist
...
-- cleanup
s:drop()
---
...
-- index name, name manipulation
-- box.schema.create_space(string.rep('t', box.schema.NAME_MAX)..'_')
-- s = box.schema.create_space(string.rep('t', box.schema.NAME_MAX - 1)..'_')
-- s.name
-- s:drop()
-- s = box.schema.create_space(string.rep('t', box.schema.NAME_MAX - 2)..'_')
-- modify index
-- ------------
--     - alter unique -> non unique
--     - alter index type
--     - add identical index - verify there is no rebuild
--     - index access by name
--     - alter add key part
--     - rename index 
--
-- build index
-- -----------
--     - index rebuild:
--        - a duplicate in the new index
--        - no field for the new index
--        - wrong field type in the new index
--
-- space cache
-- -----------
-- - all the various kinds of reference to a dropped space
--   - iterator to index
--   index to space
--   space to index
--   variable
--   key def
--   all userdata given away to lua - think how
--
--
-- -- inject error at various stages of commit and see that
-- the alter has no effects
--     - test that during commit phase
--       -> inject error at commit, inject error at rollback
--
-- usability
-- ---------
-- - space name in all error messages!
--         error: Duplicate key exists in unique index 1 (ugly)
--
-- triggers
-- --------
-- - test that after disabling triggers we can
--   create an empty snapshot
-- - test for run_triggers on/off
--
-- recovery
-- --------
--  - add primary key in snapshot
--  - add secondary key in snapshot
--  - add primary key in xlog
--  - add secondary key in xlog
--  - the same for an empty space and a space with data
--  - test start from a space entry added in xlog
--  - test start from a space entry dropped in xlog
--  - test enabled/disabled property for these
--  spaces and space from a snapshot
--
--
-- features
--------
-- - ffi function to enable/disable space
