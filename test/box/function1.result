build_path = os.getenv("BUILDDIR")
---
...
package.cpath = build_path..'/test/box/?.so;'..build_path..'/test/box/?.dylib;'..package.cpath
---
...
log = require('log')
---
...
net = require('net.box')
---
...
c = net.connect(os.getenv("LISTEN"))
---
...
box.schema.func.create('function1', {language = "C"})
---
...
box.space._func:replace{2, 1, 'function1', 0, 'LUA'}
---
- error: function does not support alter
...
box.schema.user.grant('guest', 'execute', 'function', 'function1')
---
...
_ = box.schema.space.create('test')
---
...
_ = box.space.test:create_index('primary')
---
...
box.schema.user.grant('guest', 'read,write', 'space', 'test')
---
...
c:call('function1')
---
- []
...
box.schema.func.drop("function1")
---
...
box.schema.func.create('function1.args', {language = "C"})
---
...
box.schema.user.grant('guest', 'execute', 'function', 'function1.args')
---
...
c:call('function1.args')
---
- error: invalid argument count
...
c:call('function1.args', { "xx" })
---
- error: first tuple field must be uint
...
c:call('function1.args', { 15 })
---
- [[15, 'hello']]
...
box.func["function1.args"]
---
- language: C
  setuid: false
  name: function1.args
  id: 2
...
box.func["function1.args"]:call()
---
- error: invalid argument count
...
box.func["function1.args"]:call({ "xx" })
---
- error: first tuple field must be uint
...
box.func["function1.args"]:call({ 15 })
---
- [15, 'hello']
...
box.schema.func.drop("function1.args")
---
...
box.func["function1.args"]
---
- null
...
box.schema.func.create('function1.multi_inc', {language = "C"})
---
...
box.schema.user.grant('guest', 'execute', 'function', 'function1.multi_inc')
---
...
c:call('function1.multi_inc')
---
- []
...
box.space.test:select{}
---
- []
...
c:call('function1.multi_inc', { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })
---
- []
...
box.space.test:select{}
---
- - [1, 0]
  - [2, 0]
  - [3, 0]
  - [4, 0]
  - [5, 0]
  - [6, 0]
  - [7, 0]
  - [8, 0]
  - [9, 0]
  - [10, 0]
...
c:call('function1.multi_inc', { 2, 4, 6, 8, 10 })
---
- []
...
box.space.test:select{}
---
- - [1, 0]
  - [2, 1]
  - [3, 0]
  - [4, 1]
  - [5, 0]
  - [6, 1]
  - [7, 0]
  - [8, 1]
  - [9, 0]
  - [10, 1]
...
c:call('function1.multi_inc', { 0, 2, 4 })
---
- []
...
box.space.test:select{}
---
- - [0, 0]
  - [1, 0]
  - [2, 2]
  - [3, 0]
  - [4, 2]
  - [5, 0]
  - [6, 1]
  - [7, 0]
  - [8, 1]
  - [9, 0]
  - [10, 1]
...
box.schema.func.drop("function1.multi_inc")
---
...
box.schema.func.create('function1.errors', {language = "C"})
---
...
box.schema.user.grant('guest', 'execute', 'function', 'function1.errors')
---
...
c:call('function1.errors')
---
- error: unknown error
...
box.schema.func.drop("function1.errors")
---
...
box.schema.func.create('xxx', {language = 'invalid'})
---
- error: Unsupported language 'INVALID' specified for function 'xxx'
...
-- language normalization
function func_lang(name) return (box.space._func.index[2]:select{name}[1] or {})[5] end
---
...
box.schema.func.create('f11'),                      func_lang('f11')
---
- null
- LUA
...
box.schema.func.create('f12', {language = 'Lua'}),  func_lang('f12')
---
- null
- LUA
...
box.schema.func.create('f13', {language = 'lua'}),  func_lang('f13')
---
- null
- LUA
...
box.schema.func.create('f14', {language = 'lUa'}),  func_lang('f14')
---
- null
- LUA
...
box.schema.func.create('f15', {language = 'c'}),    func_lang('f15')
---
- null
- C
...
box.schema.func.create('f16', {language = 'C'}),    func_lang('f16')
---
- null
- C
...
box.schema.func.drop("f11")
---
...
box.schema.func.drop("f12")
---
...
box.schema.func.drop("f13")
---
...
box.schema.func.drop("f14")
---
...
box.schema.func.drop("f15")
---
...
box.schema.func.drop("f16")
---
...
box.space.test:drop()
---
...
-- Missing shared library
name = 'unkownmod.unknownfunc'
---
...
box.schema.func.create(name, {language = 'C'})
---
...
box.schema.user.grant('guest', 'execute', 'function', name)
---
...
c:call(name)
---
- error: 'Failed to dynamically load module ''unkownmod'': module not found'
...
box.schema.func.drop(name)
---
...
-- Drop function while executing gh-910
box.schema.func.create('function1.test_yield', {language = "C"})
---
...
box.schema.user.grant('guest', 'execute', 'function', 'function1.test_yield')
---
...
s = box.schema.space.create('test_yield')
---
...
_ = s:create_index('pk')
---
...
box.schema.user.grant('guest', 'read,write', 'space', 'test_yield')
---
...
fiber = require('fiber')
---
...
ch = fiber.channel(1)
---
...
_ = fiber.create(function() c:call('function1.test_yield') ch:put(true) end)
---
...
while s:get({1}) == nil do fiber.yield(0.0001) end
---
...
box.schema.func.drop('function1.test_yield')
---
...
ch:get()
---
- true
...
s:drop()
---
...
-- gh-2914: check identifier constraints.
test_run = require('test_run').new()
---
...
test_run:cmd("push filter '(.builtin/.*.lua):[0-9]+' to '\\1'")
---
- true
...
identifier = require("identifier")
---
...
test_run:cmd("setopt delimiter ';'")
---
- true
...
--
-- '.' in func name is used to point out path therefore '.' in name
-- itself is prohibited
--
--
identifier.run_test(
	function (identifier)
		if identifier == "." then return end
		box.schema.func.create(identifier, {language = "lua"})
		box.schema.user.grant('guest', 'execute', 'function', identifier)
		rawset(_G, identifier, function () return 1 end)
		local res = pcall(c.call, c, identifier)
		if c:call(identifier) ~= 1 then
			error("Should not fire")
		end
		rawset(_G, identifier, nil)
	end,
	function (identifier)
		if identifier == "." then return end
		box.schema.func.drop(identifier)
	end
);
---
- All tests passed
...
test_run:cmd("setopt delimiter ''");
---
- true
...
c:close()
---
...
-- Test registered functions interface.
function divide(a, b) return a / b end
---
...
box.schema.func.create("divide")
---
...
func = box.func.divide
---
...
func.call({4, 2})
---
- error: 'builtin/box/schema.lua: Use func:call(...) instead of func.call(...)'
...
func:call(4, 2)
---
- error: 'builtin/box/schema.lua: Use func:call(table)'
...
func:call()
---
- error: '[string "function divide(a, b) return a / b end "]:1: attempt to perform
    arithmetic on local ''a'' (a nil value)'
...
func:call({})
---
- error: '[string "function divide(a, b) return a / b end "]:1: attempt to perform
    arithmetic on local ''a'' (a nil value)'
...
func:call({4})
---
- error: '[string "function divide(a, b) return a / b end "]:1: attempt to perform
    arithmetic on local ''b'' (a nil value)'
...
func:call({4, 2})
---
- 2
...
func:call({4, 2, 1})
---
- 2
...
func:drop()
---
...
func
---
- language: LUA
  setuid: false
  name: divide
  id: 2
...
func.drop()
---
- error: 'builtin/box/schema.lua: Use func:drop(...) instead of func.drop(...)'
...
box.func.divide
---
- null
...
func:drop()
---
- error: Function 'divide' does not exist
...
func:call({4, 2})
---
- error: Function 'divide' does not exist
...
box.internal.func_call('divide', 4, 2)
---
- error: Function 'divide' does not exist
...
box.schema.func.create("function1.divide", {language = 'C'})
---
...
func = box.func["function1.divide"]
---
...
func:call(4, 2)
---
- error: 'builtin/box/schema.lua: Use func:call(table)'
...
func:call()
---
- error: invalid argument
...
func:call({})
---
- error: invalid argument
...
func:call({4})
---
- error: invalid argument
...
func:call({4, 2})
---
- [2]
...
func:call({4, 2, 1})
---
- [2]
...
func:drop()
---
...
box.func["function1.divide"]
---
- null
...
func
---
- language: C
  setuid: false
  name: function1.divide
  id: 2
...
func:drop()
---
- error: Function 'function1.divide' does not exist
...
func:call({4, 2})
---
- error: Function 'function1.divide' does not exist
...
box.internal.func_call('function1.divide', 4, 2)
---
- error: Function 'function1.divide' does not exist
...
test_run:cmd("setopt delimiter ';'")
---
- true
...
function minmax(array)
	local min = 999
	local max = -1
	for _, v in pairs(array) do
		min = math.min(min, v)
		max = math.max(max, v)
	end
	return min, max
end
test_run:cmd("setopt delimiter ''");
---
...
box.schema.func.create("minmax")
---
...
func = box.func.minmax
---
...
func:call({{1, 2, 99, 3, -1}})
---
- -1
- 99
...
func:drop()
---
...
box.func.minmax
---
- null
...
-- Test access checks for registered functions.
function secret() return 1 end
---
...
box.schema.func.create("secret")
---
...
box.func.secret:call({})
---
- 1
...
function secret_leak() return box.func.secret:call() end
---
...
box.schema.func.create('secret_leak')
---
...
box.schema.user.grant('guest', 'execute', 'function', 'secret_leak')
---
...
conn = net.connect(box.cfg.listen)
---
...
conn:call('secret_leak')
---
- error: Execute access to function 'secret' is denied for user 'guest'
...
conn:close()
---
...
box.schema.user.revoke('guest', 'execute', 'function', 'secret_leak')
---
...
box.schema.func.drop('secret_leak')
---
...
box.schema.func.drop('secret')
---
...
test_run:cmd("clear filter")
---
- true
...
